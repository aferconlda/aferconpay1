
import * as functions from "firebase-functions";
import * as admin from "firebase-admin";

// Inicializa a aplicação Admin, necessária para manipular dados com privilégios de administrador
admin.initializeApp();

const db = admin.firestore();

/**
 * Verifica se o ID de um utilizador que invoca a função tem a claim de 'admin'.
 * Lança um erro se o utilizador não for um administrador.
 * @param {functions.https.CallableContext} context O contexto da chamada da função.
 */
const ensureIsAdmin = (context: functions.https.CallableContext) => {
  if (!context.auth || !context.auth.token.admin) {
    throw new functions.https.HttpsError(
      "permission-denied",
      "Apenas administradores podem executar esta operação."
    );
  }
};

/**
 * Envia uma notificação para um utilizador específico.
 * @param {string} userId O ID do utilizador a notificar.
 * @param {string} title O título da notificação.
 * @param {string} body O corpo da notificação.
 * @param {string} type O tipo de notificação (para a app saber que ícone mostrar).
 */
const sendNotification = (userId: string, title: string, body: string, type: string) => {
  return db.collection("users").doc(userId).collection("notifications").add({
    title,
    body,
    date: admin.firestore.FieldValue.serverTimestamp(),
    read: false,
    type,
  });
};


// --- CLOUD FUNCTION PARA PROCESSAR PEDIDOS DE LEVANTAMENTO ---

export const processWithdrawalRequest = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  // 1. Validar a chamada
  ensureIsAdmin(context);

  const { requestId, action } = data;
  if (!requestId || !action || !['approve', 'reject'].includes(action)) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "Faltam os parâmetros 'requestId' e 'action' ('approve' ou 'reject')."
    );
  }

  const requestRef = db.collection("withdrawal_requests").doc(requestId);

  // 2. Processar a ação
  try {
    const requestDoc = await requestRef.get();
    if (!requestDoc.exists) {
      throw new functions.https.HttpsError("not-found", "Pedido não encontrado.");
    }

    const requestData = requestDoc.data()!;
    if (requestData.status !== 'pending') {
      throw new functions.https.HttpsError(
        "failed-precondition",
        `Este pedido já foi processado (estado: ${requestData.status}).`
      );
    }

    if (action === 'approve') {
      // Aprovação: usa uma transação para garantir a consistência dos dados
      await db.runTransaction(async (transaction) => {
        const userRef = db.collection('users').doc(requestData.userId);
        const userDoc = await transaction.get(userRef);
        if (!userDoc.exists) {
          throw new functions.https.HttpsError("not-found", "Utilizador associado ao pedido não foi encontrado.");
        }

        const userBalance = userDoc.data()!.balance || 0;
        const withdrawalAmount = requestData.amount;

        if (userBalance < withdrawalAmount) {
            // Atualiza o estado do pedido para 'rejeitado' por falta de saldo
            transaction.update(requestRef, { status: 'rejected', processedAt: admin.firestore.FieldValue.serverTimestamp(), reason: 'Saldo insuficiente no momento da aprovação.' });
            // Envia notificação a explicar a rejeição automática
            await sendNotification(
                requestData.userId,
                "Levantamento Rejeitado",
                `O seu pedido de levantamento de ${withdrawalAmount.toFixed(2)} Kz foi rejeitado porque o seu saldo era insuficiente. `,
                "withdrawal_rejected"
            );
            return; // Para a transação
        }

        // Tudo OK, debita o saldo, adiciona a transação e atualiza o pedido.
        transaction.update(userRef, { balance: admin.firestore.FieldValue.increment(-withdrawalAmount) });
        
        const userTransactionRef = userRef.collection('transactions').doc();
        transaction.set(userTransactionRef, {
            amount: withdrawalAmount,
            date: admin.firestore.FieldValue.serverTimestamp(),
            description: `Levantamento Aprovado: ${requestData.beneficiaryName}`,
            type: 'expense'
        });

        transaction.update(requestRef, { status: 'completed', processedAt: admin.firestore.FieldValue.serverTimestamp() });
      });

      await sendNotification(
        requestData.userId,
        "Levantamento Aprovado",
        `O seu pedido de levantamento de ${requestData.amount.toFixed(2)} Kz foi aprovado e processado.`,
        "withdrawal_approved"
      );

    } else { // action === 'reject'
      // Rejeição: simplesmente atualiza o estado do pedido
      await requestRef.update({ status: 'rejected', processedAt: admin.firestore.FieldValue.serverTimestamp() });
      
      await sendNotification(
        requestData.userId,
        "Levantamento Rejeitado",
        `O seu pedido de levantamento de ${requestData.amount.toFixed(2)} Kz foi rejeitado pelo administrador.`,
        "withdrawal_rejected"
      );
    }

    return { success: true, message: `Pedido ${requestId} foi marcado como '${action}'.` };

  } catch (error: any) {
    console.error("Erro ao processar pedido de levantamento:", error);
    if (error instanceof functions.https.HttpsError) {
      throw error; // Re-lança erros Https
    }
    throw new functions.https.HttpsError("internal", "Ocorreu um erro inesperado.", error.message);
  }
});

/**
 * Valida se um ID de referência (referrerId) corresponde a um utilizador existente.
 */
export const validateReferrer = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  const referrerId = data.referrerId;

  if (!referrerId || typeof referrerId !== 'string') {
    throw new functions.https.HttpsError(
      'invalid-argument',
      'O ID de referência (referrerId) é obrigatório e deve ser uma string.'
    );
  }

  try {
    const userDoc = await db.collection('users').doc(referrerId).get();

    if (userDoc.exists) {
      return { isValid: true };
    } else {
      return { isValid: false };
    }
  } catch (error: any) {
    console.error("Erro ao validar referrerId:", error);
    throw new functions.https.HttpsError(
      'internal',
      'Ocorreu um erro ao verificar o código de convite. Tente novamente.'
    );
  }
});

// --- CLOUD FUNCTION PARA PROCESSAR DEPÓSITOS EM NUMERÁRIO (CAIXA) ---

export const processCashDeposit = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  // 1. Autenticação e Validação
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "A função só pode ser chamada por um utilizador autenticado."
    );
  }

  const { clientId, amount, cashierId } = data;

  if (context.auth.uid !== cashierId) {
    throw new functions.https.HttpsError(
      "permission-denied",
      "Não tem permissão para executar esta operação em nome de outro caixa."
    );
  }

  if (!clientId || typeof clientId !== "string" || !(amount > 0)) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "Dados inválidos: 'clientId' (string) e 'amount' (número positivo) são obrigatórios."
    );
  }

  const cashierRef = db.collection("users").doc(cashierId);
  const clientRef = db.collection("users").doc(clientId);

  // 2. Transação Atómica
  try {
    await db.runTransaction(async (transaction) => {
      const cashierDoc = await transaction.get(cashierRef);
      const clientDoc = await transaction.get(clientRef);

      if (!cashierDoc.exists || !clientDoc.exists) {
        throw new functions.https.HttpsError(
          "not-found",
          "O cliente ou o caixa não foi encontrado na base de dados."
        );
      }

      const cashierData = cashierDoc.data()!;
      const clientData = clientDoc.data()!;

      if (cashierData.role !== "cashier") {
        throw new functions.https.HttpsError(
          "permission-denied",
          "Esta operação só pode ser realizada por um utilizador com a função de caixa."
        );
      }

      const currentFloat = cashierData.floatBalance || 0;
      if (currentFloat < amount) {
        throw new functions.https.HttpsError(
          "failed-precondition",
          `O seu float (${currentFloat} Kz) é insuficiente para cobrir esta operação de ${amount} Kz.`
        );
      }

      transaction.update(clientRef, {
        balance: admin.firestore.FieldValue.increment(amount),
      });

      transaction.update(cashierRef, {
        floatBalance: admin.firestore.FieldValue.increment(-amount),
      });

      const clientTransactionRef = clientRef.collection("transactions").doc();
      transaction.set(clientTransactionRef, {
        description: `Depósito em numerário via caixa ${cashierData.displayName || "Desconhecido"}`,
        amount: amount,
        date: admin.firestore.FieldValue.serverTimestamp(),
        type: "revenue",
        source: "cash_deposit",
      });

      const cashierTransactionRef = cashierRef.collection("transactions").doc();
      transaction.set(cashierTransactionRef, {
        description: `Entrega de numerário ao cliente ${clientData.displayName || "Desconhecido"}`,
        amount: amount,
        date: admin.firestore.FieldValue.serverTimestamp(),
        type: "expense",
        target: "client_deposit",
      });
    });

    console.log(`Depósito de ${amount} Kz processado com sucesso pelo caixa ${cashierId} para o cliente ${clientId}.`);
    return { status: "success", message: "Depósito processado com sucesso!" };

  } catch (error: any) {
    console.error(
        `Erro ao processar depósito do caixa ${cashierId} para o cliente ${clientId}:`,
        error
    );

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }

    throw new functions.https.HttpsError("internal", "Ocorreu um erro inesperado no servidor.");
  }
});


export const manageExchangeRequest = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "É necessário estar autenticado para realizar esta operação."
    );
  }

  const { action, requestId } = data;
  const userId = context.auth.uid; // ID do caixa ou do cliente

  if (!action || !requestId) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "A função foi chamada com argumentos em falta ('action' ou 'requestId')."
    );
  }

  const requestRef = db.collection("foreign_withdrawal_requests").doc(requestId);

  return db.runTransaction(async (transaction) => {
    const requestDoc = await transaction.get(requestRef);

    if (!requestDoc.exists) {
      throw new functions.https.HttpsError(
        "not-found",
        "O pedido de câmbio especificado não foi encontrado."
      );
    }

    const requestData = requestDoc.data()!;
    const cashierRef = db.collection("users").doc(userId);

    switch (action) {
      case "accept": // CORRIGIDO de 'accept_request' para 'accept'
        const cashierDoc = await transaction.get(cashierRef);
        if (!cashierDoc.exists || cashierDoc.data()!.role !== 'cashier') {
            throw new functions.https.HttpsError(
                "permission-denied",
                "Apenas caixas podem aceitar pedidos."
            );
        }

        if (requestData.status !== "pending") {
          throw new functions.https.HttpsError(
            "failed-precondition",
            "Este pedido já foi aceite por outro caixa."
          );
        }

        transaction.update(requestRef, {
          status: "processing",
          processedBy: userId, // Atribui o ID do caixa ao pedido
          processedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        return { status: "success", message: "Pedido aceite! Pode agora processar o levantamento." };

      case "confirm_receipt":
        if (requestData.userId !== userId) {
          throw new functions.https.HttpsError(
            "permission-denied",
            "Apenas o criador do pedido pode confirmar o recebimento."
          );
        }
        if (requestData.status !== "processing") {
          throw new functions.https.HttpsError(
            "failed-precondition",
            `Não pode confirmar o recebimento de um pedido com o estado '${requestData.status}'.`
          );
        }

        transaction.update(requestRef, {
          status: "completed",
          completedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const cashierId = requestData.processedBy;
        if (!cashierId) {
            console.log(`Pedido ${requestId} concluído sem um caixa definido. Nenhuma comissão será paga.`);
            return { status: "success", message: "Pedido concluído." };
        }

        const serviceFee = requestData.serviceFee;
        const commissionRate = 0.50; // 50% de comissão
        const commissionAmount = parseFloat((serviceFee * commissionRate).toFixed(2));

        if (commissionAmount > 0) {
          const processedByCashierRef = db.collection("users").doc(cashierId);
          const commissionRef = processedByCashierRef.collection("commission_transactions").doc();

          transaction.update(processedByCashierRef, {
            commissionBalance: admin.firestore.FieldValue.increment(commissionAmount),
          });

          transaction.set(commissionRef, {
            amount: commissionAmount,
            date: admin.firestore.FieldValue.serverTimestamp(),
            originalRequestId: requestId,
            details: `Comissão pela troca de ${requestData.amountKz} Kz para ${requestData.targetCurrency}`
          });
        }
        
        console.log(`Comissão de ${commissionAmount} paga ao caixa ${cashierId} pelo pedido ${requestId}.`);

        return { status: "success", message: "Recebimento confirmado e comissão processada." };

      default:
        throw new functions.https.HttpsError(
          "invalid-argument",
          `A ação '${action}' não é reconhecida.`
        );
    }
  });
});


export const addFloatFromBalance = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "A função só pode ser chamada por um utilizador autenticado."
    );
  }

  const amount = data.amount;
  if (!(typeof amount === 'number' && amount > 0)) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "O 'amount' é obrigatório e deve ser um número positivo."
    );
  }

  const cashierId = context.auth.uid;
  const cashierRef = db.collection("users").doc(cashierId);

  try {
    await db.runTransaction(async (transaction) => {
      const cashierDoc = await transaction.get(cashierRef);

      if (!cashierDoc.exists) {
        throw new functions.https.HttpsError(
          "not-found",
          "O utilizador caixa não foi encontrado na base de dados."
        );
      }

      const cashierData = cashierDoc.data()!;

      if (cashierData.role !== "cashier") {
        throw new functions.https.HttpsError(
          "permission-denied",
          "Apenas utilizadores com a função 'cashier' podem carregar o saldo float."
        );
      }

      const currentBalance = cashierData.balance || 0;
      if (currentBalance < amount) {
        throw new functions.https.HttpsError(
          "failed-precondition",
          `O seu saldo principal (${currentBalance.toFixed(2)} Kz) é insuficiente para transferir ${amount.toFixed(2)} Kz.`
        );
      }

      transaction.update(cashierRef, {
        balance: admin.firestore.FieldValue.increment(-amount),
        floatBalance: admin.firestore.FieldValue.increment(amount),
      });

      const transactionRef = cashierRef.collection("transactions").doc();
      transaction.set(transactionRef, {
        description: `Carregamento de Saldo Float`,
        amount: amount,
        date: admin.firestore.FieldValue.serverTimestamp(),
        type: "internal_transfer",
        from: "main_balance",
        to: "float_balance",
      });
    });

    console.log(`Caixa ${cashierId} transferiu ${amount} do saldo principal para o saldo float.`);
    return { status: "success", message: "Saldo float carregado com sucesso!" };

  } catch (error: any) {
    console.error(
        `Erro ao carregar saldo float para o caixa ${cashierId}:`,
        error
    );

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }

    throw new functions.https.HttpsError("internal", "Ocorreu um erro inesperado no servidor ao processar a transferência.");
  }
});

// --- CLOUD FUNCTION PARA TRANSFERÊNCIAS P2P (ENTRE UTILIZADORES) ---

export const performP2PTransfer = functions
  .region("europe-west1")
  .https.onCall(async (data: any, context: functions.https.CallableContext) => {
    // 1. Autenticação e Validação Inicial
    if (!context.auth) {
      throw new functions.https.HttpsError(
        "unauthenticated",
        "A função só pode ser chamada por um utilizador autenticado."
      );
    }

    const senderId = context.auth.uid;
    const { recipientId, amount, description } = data;

    if (!recipientId || typeof recipientId !== "string" || !(amount > 0)) {
      throw new functions.https.HttpsError(
        "invalid-argument",
        "Dados inválidos: 'recipientId' (string) e 'amount' (número positivo) são obrigatórios."
      );
    }

    if (senderId === recipientId) {
      throw new functions.https.HttpsError(
        "invalid-argument",
        "Não pode enviar dinheiro para si mesmo."
      );
    }

    // 2. Referências aos Documentos
    const senderRef = db.collection("users").doc(senderId);
    const recipientRef = db.collection("users").doc(recipientId);
    const UNVERIFIED_TRANSACTION_LIMIT = 100000.0;

    try {
      // 3. Transação Atómica para a transferência de fundos
      await db.runTransaction(async (transaction) => {
        const senderDoc = await transaction.get(senderRef);
        const recipientDoc = await transaction.get(recipientRef);

        if (!senderDoc.exists || !recipientDoc.exists) {
          throw new functions.https.HttpsError(
            "not-found",
            "O remetente ou o destinatário não foi encontrado."
          );
        }

        const senderData = senderDoc.data()!;
        const recipientData = recipientDoc.data()!;

        const senderName = senderData.displayName || "Alguém";
        const recipientName = recipientData.displayName || "desconhecido";

        // 4. Verificação de Saldo e Limites KYC
        const senderBalance = senderData.balance || 0;
        if (senderBalance < amount) {
          throw new functions.https.HttpsError(
            "failed-precondition",
            `Saldo insuficiente. O seu saldo atual é de ${senderBalance.toFixed(2)} Kz.`
          );
        }

        if (senderData.kycStatus !== "verified") {
          const unverifiedVolume = senderData.unverifiedTransactionVolume || 0;
          const remainingLimit = UNVERIFIED_TRANSACTION_LIMIT - unverifiedVolume;
          if (amount > remainingLimit) {
            throw new functions.https.HttpsError(
              "failed-precondition",
              `Limite para contas não verificadas excedido. O seu limite restante é de ${remainingLimit.toFixed(2)} Kz.`
            );
          }
          transaction.update(senderRef, {
            unverifiedTransactionVolume: admin.firestore.FieldValue.increment(amount),
          });
        }

        // 5. Execução da Transferência
        transaction.update(senderRef, { balance: admin.firestore.FieldValue.increment(-amount) });
        transaction.update(recipientRef, { balance: admin.firestore.FieldValue.increment(amount) });

        // 6. Criação de Registos de Transação
        const senderTransactionRef = senderRef.collection("transactions").doc();
        transaction.set(senderTransactionRef, {
          amount,
          date: admin.firestore.FieldValue.serverTimestamp(),
          description: description || `Transferência para ${recipientName}`,
          type: "expense",
          recipientId,
          recipientName,
        });

        const recipientTransactionRef = recipientRef.collection("transactions").doc();
        transaction.set(recipientTransactionRef, {
          amount,
          date: admin.firestore.FieldValue.serverTimestamp(),
          description: `Recebido de ${senderName}`,
          type: "revenue",
          senderId,
          senderName,
        });
      });

      // 7. Envio de Notificações (Pós-Transação)
      try {
        const senderDoc = await senderRef.get();
        const recipientDoc = await recipientRef.get();

        const senderName = senderDoc.data()?.displayName || "Alguém";
        const recipientName = recipientDoc.data()?.displayName || "desconhecido";

        await sendNotification(
          recipientId,
          "Transferência Recebida",
          `${senderName} enviou-lhe ${amount.toFixed(2)} Kz.`,
          "transfer_in"
        );
        await sendNotification(
          senderId,
          "Transferência Enviada",
          `Enviou ${amount.toFixed(2)} Kz para ${recipientName}.`,
          "transfer_out"
        );
      } catch (notificationError) {
        console.error("A transferência foi bem sucedida, mas o envio de notificações falhou:", notificationError);
        // Não lançar erro aqui, pois a transação financeira foi concluída.
      }

      return { status: "success", message: "Transferência realizada com sucesso!" };

    } catch (error: any) {
      console.error(`Erro na transferência de ${senderId} para ${recipientId}:`, error);
      if (error instanceof functions.https.HttpsError) {
        throw error;
      }
      throw new functions.https.HttpsError("internal", "Ocorreu um erro inesperado no servidor.", error.message);
    }
  });
